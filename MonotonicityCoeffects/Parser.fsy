%{
open Ast
%}

%start start
%type < Ast.Prog > start
%start Ty
%type < Ast.Ty > Ty

%token <string> ID CONST
%token <System.Int32> INT
%token <System.Double> FLOAT
%token TRUE FALSE FUN COLON EQUAL 
%token BOT JOIN EXTRACT CONS IGET ISET 
%token AT DOT PLUS MINUS QUESTION ASTERISK LPAREN RPAREN IN LET END EOF FST SND COMMA OF CASE 
%token INL INR TO CAP UNCAP PIPE TYPES SEMICOLON LBRACK RBRACK BANG
%token HASH DICT TOSET PROSET SEMILATTICE FORALL BIGFORALL IMPLIES ARROW
%token LSQUAREBRACKET RSQUAREBRACKET LARROW AND

%right ARROW DICT PLUS ASTERISK IMPLIES

%%

start: TYPES TypeAliasList IN Expr { { typeAliases = Map<string,Ty>($2) ; exprAliases = Map.empty ;  body = $4 } }
     | Expr { { typeAliases = Map.empty; exprAliases = Map.empty ;  body = $1 } }

TypeAlias : ID EQUAL Ty SEMICOLON { ($1,$3) }
TypeAliasList : TypeAliasList SEMICOLON TypeAlias { $3 :: $1 }
              | TypeAlias { [$1] }

ProperKindPrime : TOSET { Toset }
		        | PROSET { Proset }
		        | SEMILATTICE { Semilattice }

ProperKind : ProperKindPrime { KProper(Set [$1 ; Proset], parseState.ResultRange) }

Kind : ProperKind { $1 }
     | ProperKindPrime IMPLIES Kind { KOperator($1,$3,parseState.ResultRange) }

ExprList : ExprList Expr { App($1,$2, parseState.ResultRange) }
		 | ExprList BANG Ty { ForallApp($1, $3, parseState.ResultRange) }
         | Expr { $1 }

LetList : ID EQUAL Expr IN Expr END { Let($1,$3,$5, parseState.ResultRange) }
        | ID EQUAL Expr AND LetList { Let($1,$3,$5,parseState.ResultRange) }

ParList : LPAREN ID COLON Ty RPAREN ParList { Abs($2,$4,$6,parseState.ResultRange) }
        | LPAREN ID COLON ProperKindPrime RPAREN ParList { Forall($2,$4,$6, parseState.ResultRange) }
		| Expr { $1 }

Expr: INT                        { Int($1, parseState.ResultRange) }
	| FLOAT                      { Float($1, parseState.ResultRange) }
	| FUN ParList END { $2 }
	| LET LetList { $2 }
	| CONST { Const($1, parseState.ResultRange) }
	| ID { Var($1, parseState.ResultRange) }
	| BOT Ty { Bot($2, parseState.ResultRange) }
	| JOIN Ty Expr Expr { Join($2, $3, $4, parseState.ResultRange) }
	| CONS Expr Expr Expr { Cons($2, $3, $4, parseState.ResultRange) }
	| FST Expr { Fst($2, parseState.ResultRange) }
	| SND Expr { Snd($2, parseState.ResultRange) }
	| LPAREN ExprList RPAREN { $2 }
	| LPAREN Expr COMMA Expr RPAREN { Pair($2, $4, parseState.ResultRange) }
	| CASE Expr TO Ty OF INL ID ARROW Expr INR ID ARROW Expr 
	  { Case($2, $4, $7, $9, $11, $13, parseState.ResultRange) }
	| INL Ty Ty Expr { Inl($2,$3,$4, parseState.ResultRange) }
	| INR Ty Ty Expr { Inr($2,$3,$4, parseState.ResultRange) }
	| CAP Scalar Expr { Cap($2, $3, parseState.ResultRange) }
	| LET CAP Scalar ID EQUAL Expr IN Expr { Uncap($3, $4, $6, $8, parseState.ResultRange) }
	| PIPE Expr PIPE { ISet($2, parseState.ResultRange) }
	| LET PIPE ID PIPE EQUAL Expr IN Expr END { IGet($3, $6, $8, parseState.ResultRange) }
	| LET CONS Ty ID ID ID EQUAL Expr IN Expr END { Extract($3,$4,$5,$6,$8,$10, parseState.ResultRange) }
	| LET LSQUAREBRACKET ID RSQUAREBRACKET LARROW Expr IN Expr { MLet($3,$6,$8, parseState.ResultRange) }
	| LSQUAREBRACKET Expr RSQUAREBRACKET { MRet($2, parseState.ResultRange) }

Scalar: PLUS         { CoeffectMonotone }
      | MINUS        { CoeffectAntitone }
	  | ASTERISK     { CoeffectRobust }
	  | QUESTION     { CoeffectAny }

TyList : TyList Ty { ForallTyApp($1,$2, parseState.ResultRange) }
       | Ty { $1 }

Ty: HASH ID { BaseTy($2, parseState.ResultRange) }
  | LPAREN Ty Scalar RPAREN { Capsule($2, $3, parseState.ResultRange) }
  | Ty ARROW Scalar Ty { FunTy($1,$3,$4, parseState.ResultRange) }
  | Ty DICT Ty { Dictionary($1,$3, parseState.ResultRange) }
  | Ty PLUS Ty { Sum($1,$3, parseState.ResultRange) }
  | Ty ASTERISK Ty { Prod($1,$3, parseState.ResultRange) }
  | PIPE Ty PIPE { IVar($2, parseState.ResultRange) }
  | ID { TyAlias($1, parseState.ResultRange) }
  | LPAREN BIGFORALL ID COLON ProperKindPrime DOT Ty RPAREN { ForallTy($3,$5,$7, parseState.ResultRange) }
  | LPAREN TyList RPAREN { $2 } 