types
  Set = typefun (x : TOSET) x |> Bool end;
  NodeId = Nat;
  // maps each node id to the shortest known path length to that node
  SPMap = NodeId |> NatU;
  EdgeSet = NodeId |> NatU;
  Graph = NodeId |> EdgeSet;
in

let equal =

	fun (A : TOSET) (x : A) (y : A)
		(bAnd 
		  (bNot (x < y)) 
		  (bNot (y < x)))
	end

and monoIf = 

  fun (src : SEMILATTICE) (dest : SEMILATTICE) (cond : src) (res : dest)
      let extract to dest with k v acc = { unit -> cond : Unit |> src } in
		res
      end
  end

and lookup = 

  fun (K : TOSET) (V : SEMILATTICE) (d : K |> V) (k : K)
    let extract to V with k2 v acc = d
    in (monoIf !Bool !V (equal !K k k2) v)
    end 
  end

and relax =
  
  fun (g : Graph) 
    hom (x : SPMap . (?Nat)*NatU)
      // when we extract the natural number n from a ?-capsule, we can use n 
      // arbitrarily, while still using the capsule (fst x) monotonically
      let cap ? n = fst x 
      and dist = snd x
      and extract to NodeId |> NatU with k v acc = (lookup !NodeId !EdgeSet g n)
      in { k -> (plusU dist v) : NodeId |> NatU }
      end
    end
  end 

and graph =
 
  {
    1 -> { 2 -> u1 : EdgeSet },
    2 -> { 1 -> u1, 3 -> u1, 4 -> u5 : EdgeSet },
    3 -> { 2 -> u1, 4 -> u1 : EdgeSet },
    4 -> { 2 -> u5, 3 -> u1, 5 -> u1 : EdgeSet },
    5 -> { 4 -> u1 : EdgeSet }
    : Graph
  }

in
 (relax graph { 1 -> u0 : SPMap })
end
