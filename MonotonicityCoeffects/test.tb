types
  set = (TypeFun x : TOSET . x |> Bool); 
in

let monoIf = 
  fun (src : SEMILATTICE) (dest : SEMILATTICE) (cond : src) (res : dest)
      let cons dest k v acc = cons unit cond (bot (Unit |> src)) in 
		res
      end
  end
and setAdd =
	fun (elemTy : TOSET) (elem : elemTy) (s : set elemTy)
		cons elem true s
	end
and setCount =
	fun (elemTy : TOSET) (s : set elemTy)
		let cons Nat key val acc = s in
			(plus acc 1)
		end
	end	
and test1 =
	fun (x : Nat) join Nat x 4 end
and test2 = 
	cons 2 true (cons 3 true (bot (set Nat)))
and test3 = 
	fun (o : Nat) @(+ o) 
		fun (kva : Unit * Bool * Nat) @(* kva)
			o
		end
	end
and test4 = 
	fun (x : Bool) :: Nat @(+ x)
	  (monoIf !Bool !Nat x 5)
	end
in
	test4
end